"""
The operator is a rule-based module with a well-defined execution flow that manages interaction among other modules in the hub, with spokes (i.e., isolated app instances), and between spokes.
"""
import socket
import multiprocessing
import uuid
import platform
from llama_index.core.llms import ChatMessage, MessageRole

from .sock import Socket
from .message import Message
from .permission import get_user_consent
from .sandbox import TIMEOUT
from .vanilla_spoke import VanillaSpoke
from .spoke import Spoke

if platform.system() != "Linux":
    from multiprocessing import set_start_method

    set_start_method("fork")


class HubOperator:
    """HubOperator is used to route queries and manage the Spokes.

    The operator is a rule-based module with a well-defined execution flow
    that manages interaction among other modules in the hub, with spokes
    (i.e., isolated app instances), and between spokes.
    """

    def __init__(self, tool_importer, user_id) -> None:
        """Initialize the HubOperator.

        Args:
            tool_importer: An instance of ToolImporter to manage tools and their functions.
            user_id: Identifier for the user.
        """
        self.tool_importer = tool_importer

        # Maintain tool information
        self.tool_functions = self.tool_importer.get_tool_functions()
        self.tools = self.tool_importer.get_all_tools()

        self.function_tools = {}
        for tool, functions in self.tool_functions.items():
            for function in functions:
                self.function_tools[function] = tool

        self.tool_names = self.tool_importer.get_tool_names()

        # Maintain a dictionary of Spoke and tool mapping
        self.spoke_tool = {}

        # Maintain a vanilla spoke
        self.vanilla_spoke = None

        # Maintain a spoke counter
        self.spoke_counter = 0

        # Get user_id
        self.user_id = user_id

        # Maintain a plan and a app list generated by the planner
        self.plan = {}
        self.app_list = []

        self.query = ""

    def run(self, query, plan):
        """Run hub operator to route user queries.

        Args:
            query (str): The user query.
            plan (dict): The plan generated to address the query by the hub planner.

        Returns:
            str: The result of processing the query.
        """
        self.query = query

        # Filter the plan
        self.filter_plan(plan)
        num_step_list = len(self.plan)

        # No app is needed to address the user query
        if num_step_list == 0:
            if self.vanilla_spoke is None:
                self.vanilla_spoke = VanillaSpoke()
            results = self.vanilla_spoke.chat(query)

        # Apps are executed in cascaded manner
        elif num_step_list == 1:
            startup_app = self.plan[0][0]["name"]
            results = self.run_initial_spoke(query, startup_app)

        # Apps can be executed in concurrent manner, use a dedicated spoke for routing the query
        else:
            startup_app = ""
            results = self.run_initial_spoke(query, startup_app)

        return results

    def filter_plan(self, plan):
        """Filter the plan based on available tools and group the steps.

        Args:
            plan (dict): The plan generated by the planner.
        """
        filtered_steps = [
            step for step in plan["steps"] if step["name"] in self.tool_names
        ]
        output_key_to_step = {}
        grouped_steps = []

        for step in filtered_steps:
            # Determine if the step is dependent on a previous step
            dependent = False
            for input_value in step["input"].values():
                if (
                    isinstance(input_value, str)
                    and input_value.startswith("<")
                    and input_value.endswith(">")
                ):
                    dependent_key = input_value[1:-1]
                    if dependent_key in output_key_to_step:
                        dependent = True
                        grouped_steps[output_key_to_step[dependent_key]].append(step)
                        break

            # If the step is not dependent on any previous step's output, start a new group
            if not dependent:
                grouped_steps.append([step])

            # Record the output key of this step
            if "output" in step:
                output_key_to_step[step["output"]] = len(grouped_steps) - 1

        self.plan = grouped_steps
        self.app_list = [
            [step["name"] for step in step_list] for step_list in self.plan
        ]
        self.app_data_dict = {
            step["name"]: step["input"] for step_list in self.plan for step in step_list
        }

    def run_initial_spoke(self, query, startup_app):
        """Run initial spoke with user permissions.

        Args:
            query (str): The user query.
            startup_app (str): The initial app to start with.

        Returns:
            str: The result of the initial spoke execution.
        """
        consent = True
        shared_data_dict = None
        if startup_app:
            action_message = (
                f'Your request "{query}" requires executing "{startup_app}"'
            )
            consent = get_user_consent(
                self.user_id, startup_app, action_message, True, "exec"
            )
            shared_data_dict = self.app_data_dict[startup_app]

        if not consent:
            results = "User denied the request"

        else:
            if shared_data_dict:
                all_empty = all(value == "" for value in shared_data_dict.values())
                if all_empty:
                    shared_data_dict = None
            results = self.execute_app_spoke(query, shared_data_dict, startup_app, True)

        return results

    def execute_app_spoke(self, query, shared_data_dict, requested_app, flag=False):
        """Execute a Spoke to solve a step.

        Args:
            query (str): The user query.
            shared_data_dict (dict): Shared data dictionary.
            requested_app (str): The app to execute.
            flag (bool): Default to False.

        Returns:
            str: The result of the spoke execution.
        """
        # Check whether the Spoke exists
        if requested_app in self.spoke_tool:
            print("Using " + requested_app + " spoke ...\n")
            # Use the existing Spoke to solve this step
            session_id = uuid.uuid4()
            spoke_id = self.spoke_tool[requested_app]["id"]
            spoke_session_id = (
                self.user_id + ":" + str(spoke_id) + ":" + str(session_id)
            )
            spoke = self.spoke_tool[requested_app]["spoke"]

            if shared_data_dict:
                action_message = (
                    f'Your data "{shared_data_dict}" is sharing with "{requested_app}"'
                )
                data_consent = get_user_consent(
                    self.user_id, requested_app, action_message, False, "data"
                )
                if not data_consent:
                    shared_data_dict = None

            # Create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            if shared_data_dict:
                shared_data = [
                    ChatMessage(
                        role=MessageRole.USER,
                        content=("Data shared by the user:" + str(shared_data_dict)),
                    ),
                ]
            else:
                shared_data = None

            p = multiprocessing.Process(
                target=spoke.run_process,
                args=(child_sock, query, spoke_session_id, shared_data),
            )
            p.start()
            results = self.handle_request(parent_sock)
            p.join(timeout=TIMEOUT)
            child.close()
            return results

        elif requested_app == "":
            # Create a dedicated Spoke to route the query
            # Create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            collab_functionalities = self.tool_importer.get_collab_functions()

            session_id = uuid.uuid4()
            spoke_session_id = (
                self.user_id + ":" + str(self.spoke_counter) + ":" + str(session_id)
            )
            spoke = Spoke(tools=[], collab_functions=collab_functionalities)
            self.spoke_counter += 1

            if shared_data_dict:
                shared_data = [
                    ChatMessage(
                        role=MessageRole.USER,
                        content=("Data shared by the user:" + str(shared_data_dict)),
                    ),
                ]
            else:
                shared_data = None

            p = multiprocessing.Process(
                target=spoke.run_process,
                args=(child_sock, query, spoke_session_id, shared_data),
            )
            p.start()
            results = self.handle_request(parent_sock)
            p.join(timeout=TIMEOUT)
            child.close()
            return results

        else:
            # Create a new Spoke to solve this step
            # get the tool object based on the tool name
            print("Using " + requested_app + " spoke ...\n")
            tool = next(t for t in self.tools if t.metadata.name == requested_app)

            collab_functionalities = self.tool_importer.get_collab_functions(
                requested_app
            )

            # Create sockets
            parent, child = socket.socketpair()
            parent_sock = Socket(parent)
            child_sock = Socket(child)

            session_id = uuid.uuid4()
            spoke_session_id = (
                self.user_id + ":" + str(self.spoke_counter) + ":" + str(session_id)
            )
            self.spoke_tool[requested_app] = {
                "id": self.spoke_counter,
                "spoke": Spoke(tools=[tool], collab_functions=collab_functionalities),
                "tool": tool,
            }
            self.spoke_counter += 1

            spoke = self.spoke_tool[requested_app]["spoke"]

            if shared_data_dict:
                action_message = (
                    f'Your data "{shared_data_dict}" is sharing with "{requested_app}"'
                )
                data_consent = get_user_consent(
                    self.user_id, requested_app, action_message, False, "data"
                )
                if not data_consent:
                    shared_data_dict = None

            if shared_data_dict:
                shared_data = [
                    ChatMessage(
                        role=MessageRole.USER,
                        content=("Data shared by the user:" + str(shared_data_dict)),
                    ),
                ]
            else:
                shared_data = None

            p = multiprocessing.Process(
                target=spoke.run_process,
                args=(child_sock, query, spoke_session_id, shared_data),
            )
            p.start()
            results = self.handle_request(parent_sock)
            p.join(timeout=TIMEOUT)
            child.close()
            return results

    def handle_request(self, parent_sock):
        """Handle different types of requests/responses from Spokes.

        Args:
            parent_sock (Socket): The socket to communicate with the parent process.

        Returns:
            str: The final response from the spokes.
        """
        while True:
            data = parent_sock.recv()

            if data["message_type"] == "final_response":
                return data["response"]

            if data["message_type"] == "function_probe_request":
                function = data["requested_functionality"]
                spoke_session_id = data["spoke_id"]

                if function not in self.function_tools:
                    response = Message.no_functionality_response(
                        spoke_session_id, function
                    )
                    parent_sock.send(response)
                    continue

                request_app = ""
                spoke_id = spoke_session_id.split(":")[1]
                for app, spoke in self.spoke_tool.items():
                    if str(spoke["id"]) == spoke_id:
                        request_app = app
                        break

                app = self.function_tools[function]

                flag = False
                if request_app:
                    action_message = f'"{request_app}" requests to execute "{app}"'

                    for step_app_list in self.app_list:
                        if app in step_app_list and request_app in step_app_list:
                            flag = True
                            break

                    consent = get_user_consent(
                        self.user_id,
                        request_app + "->" + app,
                        action_message,
                        flag,
                        "collab",
                    )

                else:
                    action_message = (
                        f'Your request "{self.query}" requires executing "{app}"'
                    )

                    for step_app_list in self.app_list:
                        if app in step_app_list:
                            flag = True
                            break

                    consent = get_user_consent(
                        self.user_id, app, action_message, flag, "exec"
                    )

                if not consent:
                    response = Message.functionality_denial_response(
                        spoke_session_id, function
                    )
                else:
                    functionality_spec = self.tool_importer.get_tool_spec(function)
                    response = Message.function_probe_response(
                        spoke_session_id, functionality_spec
                    )

                parent_sock.send(response)

            if data["message_type"] == "app_request":
                functionality_request = data["functionality_request"]
                spoke_session_id = data["spoke_id"]

                if functionality_request not in self.function_tools:
                    response_message = functionality_request + " not found"
                    response = Message.no_functionality_response(functionality_request)
                else:
                    tool = self.function_tools[functionality_request]

                    shared_data_dict = None
                    if tool in self.app_data_dict:
                        shared_data_dict = self.app_data_dict[tool]
                        if shared_data_dict:
                            all_empty = all(
                                value == "" for value in shared_data_dict.values()
                            )
                            if all_empty:
                                shared_data_dict = None

                    app_response = self.execute_app_spoke(
                        str(data), shared_data_dict, tool, False
                    )
                    response_message = app_response
                    response = Message.app_response(spoke_session_id, app_response)

                if request_app:
                    action_message = f'"{app}" is returning the following response to "{request_app}":\n"{response_message}"'
                    consent = get_user_consent(
                        self.user_id,
                        app + "->" + request_app,
                        action_message,
                        True,
                        "collab",
                    )
                else:
                    action_message = f'"{app}" is returning the following response:\n"{response_message}"'
                    consent = get_user_consent(
                        self.user_id, app, action_message, True, "collab"
                    )

                if consent:
                    parent_sock.send(response)
                else:
                    parent_sock.send(
                        Message.no_functionality_response(functionality_request)
                    )
